📌 概要

「push_swap」は スタックAとスタックBの2つを使い、決まった操作だけで数字を昇順に並べ替える プログラムを書く課題です。
使える操作にはサイクルやプッシュ系・回転系などがあり、最終的に スタックAにソート済みリストを作る 必要があります。

この記事では、
そのアルゴリズム部分の解法（Turkアルゴリズム）を6つのステップで説明 しています。

🧠 前提

著者は以下が既にできていることを想定しています：

✔ スタックA, Bのデータ構造が作れている
✔ 操作 (pa, pb, sa, sb, etc.) を実装済み
✔ 3つの数字をソートする関数が書ける

（3数ソートは全パターンをハードコードしてもOK、と著者は言っています）

🧱 Turkアルゴリズム（6ステップ）
① pb を繰り返して全部Bへ送る

まず スタックAの要素を片っ端からBに移す（pb を繰り返す）
→ Aに 3つだけ残す。

理由は（3つだけなら簡単にソートできるから）。

② スタックAの3つをソート

残った3つをソートする関数で並べる。
ここから「正しい位置に戻す処理」が本格化します。

③ 「ターゲットノード」を決める

スタックBのひとつをAに戻す際、
どこに入れるのが一番よいかを決めます。

ルール：

対象は Bのノード X に対して、
「A内で X より大きい最小のノード」。
これを ターゲットノード とします。

例：

Bの4に対して → Aの7と8が候補 → 小さい方の 7 がターゲット

Bの値が Aの最大より大きい場合 → Aの最小値の上に置く（最後の調整が楽になるため）

④ 「bring to top cost（トップまでのコスト）」を計算

BのノードをAへ移す時、
そのノードがスタックの上に来るまでの操作回数を計算します。

考え方：

回転（上へ移動）か逆回転（下へ移動）かを判断
→ ノードのインデックスで計算します

インデックスがスタック半分以内なら回転、それ以上なら逆回転が最短

このノードの「A側ターゲットノード」のコストも同様に計算して、
Bのノード + Aのターゲットの総合コスト を求めます。

⑤ 「最小コストのノード」を選ぶ

ステップ④で出した合計コストから、
最も 操作数が少ないノード を見つけます。
（同じ値なら上にある方を優先する、と著者はしています）

⑥ 実際に操作を実行する

選んだノードについて、

Bを回してそのノードをトップにする

Aを回してターゲットノードをトップにする

pa でAへ戻す

これを繰り返します。

🔁 ループ + 最終調整

上記③〜⑥を Bが空になるまで繰り返す。
最後に A の最小値をトップに持ってきて完成 です。

✏️ 補足（著者の反省）

コスト計算で 同時回転（rr, rrr）の考慮 を入れられなかったため、
ベストな手数にはならなかったと言っています。（結果として500個で約5600操作）

🧾 まとめ（噛み砕き版）

このアルゴリズムは：

➡ スタックBへ全部移す
➡ 3つだけソート
➡ 戻す順番をコストベースで最適化
➡ 最終的にAを整えて完成

という感じで、より効率的に push_swap をクリアするための手法 です。

必要なら、この記事内で使われている 擬似コード化や図の内容 もわかりやすく整理して説明できますよ。🙂
